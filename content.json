{"meta":{"title":"自瞄小良の博客","subtitle":"记录学习点点滴滴","description":"中北大学在校学生,菜鸟一个","author":"小良","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"Mybatis 总结","date":"2020-10-29T10:30:40.925Z","updated":"2020-10-29T13:05:20.882Z","comments":true,"path":"2020/10/29/Mybatis 总结/","link":"","permalink":"http://example.com/2020/10/29/Mybatis%20%E6%80%BB%E7%BB%93/","excerpt":"Mybatis 总结原理","text":"Mybatis 总结原理 动态代理四大特点:1.接口类和xml文件名称一致 2.xml文件中id 为接口中的方法名 3.pamameterType 为入参类型 对应接口中传入的参数 4.resultType 为返回结果类型 对应接口中返回值的类型 步骤0.加载资源文件 12String source=&quot;sqlMapconfig.xml&quot;;InputStream is=Resources.getResourceAsStream(source); 1 .创建SqlSessionFactory 对象 1SqlSessionFactory sf=new SqlSessionFactoryBuilder().build(is); 2.创建SqlSession 对象 1SqlSession session=sf.openSession(); //构造方法 3.执行sql语句 动态代理实现模糊查询12UserMapper mapper = session.getMapper(UserMapper.class);List&lt;Users&gt; us=mapper.selectUsersByname(&quot;张&quot;); log4j一对多多对一","categories":[],"tags":[]},{"title":"","slug":"jsp+servlet总结","date":"2020-10-29T10:30:39.600Z","updated":"2020-10-29T12:23:32.894Z","comments":true,"path":"2020/10/29/jsp+servlet总结/","link":"","permalink":"http://example.com/2020/10/29/jsp+servlet%E6%80%BB%E7%BB%93/","excerpt":"jsp+servlet总结servlet 和请求路径绑定两种方式: 注解 配置xml文件 post请求乱码解决​ request.setCharacterEncoding(&quot;utf-8&quot;); //设置编码格式 ​ response.setCharacterEncoding(&quot;utf-8&quot;); //设置编码格式 ​ response.setContentType(&quot;typr/html; charset=utf-8&quot;) //设置文档类型","text":"jsp+servlet总结servlet 和请求路径绑定两种方式: 注解 配置xml文件 post请求乱码解决​ request.setCharacterEncoding(&quot;utf-8&quot;); //设置编码格式 ​ response.setCharacterEncoding(&quot;utf-8&quot;); //设置编码格式 ​ response.setContentType(&quot;typr/html; charset=utf-8&quot;) //设置文档类型 get请求乱码解决​ 1.修改Tomcat 中server 配置文件 ​ URIEncoding=&quot;utf-8&quot; ​ 2. 通过new String 方式 ​ new String(name.getBytes(&quot;iso-8859&quot;),&quot;UTF-8&quot;); 转发和重定向​ 1.转发 ​ request.getRequestDispatcher(&quot;目标地址&quot;).forward(request,response); ​ 2.重定向 ​ response.sendRedirect(&quot;目标地址&quot;); ​ 转发的特点 ​ 地址不变，是服务器内部的一次转发,实则为一次请求 ​ 重定向 ​ 地址改变,实则为两次请求 域对象 (范围从小到大)​ 1.Pagecontext ​ 作用范围为 整个jsp页面 ​ 2.ServletRequest ​ 作用范围为 整个请求链 （请求转发也算，因为转发实则为一次请求） ​ 获得客户端信息，可通过getRequestURL()、getRequestURI()、getQueryString()、getPathInfo()、getRemoteAddr()、getRemoteHost()、 ​ getRemotePort()、getLocalAddr()、getLocalName() ​ 3.Session ​ 存储在服务器端 ​ 作用范围为 一次会话 ​ sessionid 存储在cookie 中 当关闭浏览器session并没有消失 只是sessionid 失效 因此无法获取数据 ​ 调用session的invalidate()方法可以立即销毁session ​ 4.ServletContext ​ 作用范围为全局 ，当服务器关闭时会失效 JSP的本质为servlet过滤器和监听器​ filter and listener ​ 执行顺序 listener &gt; filter &gt; servlet ​ 监听器可以监听 域对象的创建和销毁 ，变量的创建和销毁，等等 ​ 常用: 统计在线人数 ​ 过滤器 (两种方式配置，和servlet 相同) ​ 实例: 不登陆不法看到购物车 所以需要过滤 一部分url El表达式(expression language)​ 语法 ${ Person.name } (Person为对象) ​ 取出4大域对象中保存的数据 JSTL​ 主要库 core (以下为引入) 前缀通常为 c ​ &lt;%@taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt; ​ if 和 foreach AJAX​ AJAX = 异步的 JavaScript 和 xml ​ 传统的网页 如果需要更新内容 需要加载整个页面 AJAX请求的步骤 (原生) : 创建引擎 ​ var xhr =new XMLHttpRequest(); 创建连接 ​ xhr.open(&quot;get&quot;,&quot;ajax?var=&quot;+var); 发送消息 ​ xhr.send(null); 接收数据 ​ xhr.onreadystatechange=function ()&#123; ​ if (xhr.readystate==4&amp;&amp;xhr.status==200)&#123; ​ object.innerHTML=xhr.responseText; ​ &#125; ​ &#125; jquery使用​ $.get(&quot;url&quot;,&#123;&quot;name&quot;:name&#125;,function(data)&#123; ​ //data为服务器返回的数据 ​ $(&quot;#div&quot;).html(data); ​ &#125;) ​ $.post(&quot;url&quot;,&#123;&quot;age&quot;:age&#125;.function(data)&#123; ​ //同上 ​ &#125;)","categories":[],"tags":[]},{"title":"","slug":"CSS 总结","date":"2020-10-29T10:30:37.005Z","updated":"2020-10-29T12:24:01.359Z","comments":true,"path":"2020/10/29/CSS 总结/","link":"","permalink":"http://example.com/2020/10/29/CSS%20%E6%80%BB%E7%BB%93/","excerpt":"CSS 总结CSS概念 (cascading style sheet)​ 层叠样式表 ​ HTML页面的样式( css 用于美化 html 页面) 如何引入 行内样式 1&lt;P style=&quot;color:red&quot; &gt; 这是一个段落 &lt;/p&gt;","text":"CSS 总结CSS概念 (cascading style sheet)​ 层叠样式表 ​ HTML页面的样式( css 用于美化 html 页面) 如何引入 行内样式 1&lt;P style=&quot;color:red&quot; &gt; 这是一个段落 &lt;/p&gt; 内嵌样式 12345&lt;style type=&quot;text/css&quot;&gt; p&#123; color: blue; &#125;&lt;/style&gt; 外部样式 1&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/style.css&quot; /&gt; ​ 说明: href =”引入外部样式文件” CSS的语法​ 选择器{ ​ 声明1; ​ 声明2; ​ } ​ 说明: 声明为 样式属性名 : 样式的值; 选择器1.基本选择器​ 1.标签选择器 ​ 2.类选择器 ​ 3.id 选择器 2.组合选择器​ 1.并集选择器 ​ 2.交集选择器 ​ 3.后代选择器 ​ 4.子集选择器 3.属性选择器1234input[name=&quot;us&quot;]&#123;border : 1px solid red;height : 38px;&#125; 4.通用选择器123*&#123;color : red; &#125; CSS的样式1.文本样式​ text-align : left center right ​ color : red ​ line-height : 行高 (高度/垂直居中) // 当 line-height ==height 时 -&gt; 垂直居中 2.字体样式​ font-size : 字体大小 ​ font-weight : border bold normal lighter (权重-粗细) ​ font-family : “blackadder itc”,”宋体” (类型) 3.背景样式​ background-color : 颜色 ​ background- image: 背景图像 url(“地址”) ​ background -repeat : 平铺方式 no-repeat repeat-x repeat-y repeat repeat为默认 ​ background -position : 定位 ​ 水平: left center right left为默认 ​ 垂直: top center bottom top为默认 ​ 具体值: 10px 20px 4.列表样式​ list-style-type : disc (符号 disc circle square) ​ list-style-image : url(“ “) (图像) ​ list-style-position : (inside/outside) ​ list-style : none 去掉符号 标准文档流1.浮动​ float : left right ​ 清楚浮动 : clear : left right both 2.定位​ position : absolute(绝对定位) relative(相对定位) fixed(固定定位) static(静态定位) ​ 绝对定位: 按父容器定位 脱离文档流(如果父容器没有定位 按body定位) ​ 相对定位 : 按自身位置定位 不会脱离文档流 盒子模型​ 外边距 : margin ​ 内边距 ：padding ​ 边框 ：border ​ 水平居中 margin：0px auto ​ 去掉默认边距 ： *{ margin : 0px; padding : 0px;} 伪类​ a:link 默认链接的样式 a:visitid 连接后的样式 ​ a:hover 鼠标悬停时的样式 ​ a:active 按下鼠标时的样式 display : block (块’,显示) inline (行) none(隐藏)","categories":[],"tags":[]},{"title":"","slug":"JDBC 总结","date":"2020-10-29T10:30:34.854Z","updated":"2020-10-29T12:23:42.171Z","comments":true,"path":"2020/10/29/JDBC 总结/","link":"","permalink":"http://example.com/2020/10/29/JDBC%20%E6%80%BB%E7%BB%93/","excerpt":"JDBC 总结JDBC简介1.什么是JDBC（Java Database Connective）​ Sun公司提供的一套执行sql 语句的API 主要由接口组成 可以为多种关系型数据库提供统一访问 ​ Sun公司为简化开发 提供了一套JDBC接口 这套接口由数据库厂商实现,开发人员只需学习JDBC接口 并通过JDBC加载具体的驱动 就可以操作数据库 2.JDBC 需要的jar​ a,java,sql ​ b,javax,sql ​ c,数据库驱动包","text":"JDBC 总结JDBC简介1.什么是JDBC（Java Database Connective）​ Sun公司提供的一套执行sql 语句的API 主要由接口组成 可以为多种关系型数据库提供统一访问 ​ Sun公司为简化开发 提供了一套JDBC接口 这套接口由数据库厂商实现,开发人员只需学习JDBC接口 并通过JDBC加载具体的驱动 就可以操作数据库 2.JDBC 需要的jar​ a,java,sql ​ b,javax,sql ​ c,数据库驱动包 JDBC的开发步骤​ 1,DriverManager 加载驱动 1Class.forName(&quot;com.mysql.jdbc.Driver&quot;) //反射 ​ 2.获取connection 连接 1Connection con=DriverManager.getConnection(&quot;jsbc:mysql:///school?useSSl=true&quot;,&quot;root&quot;,&quot;123456&quot;) //防止乱码 ?characterEncoding=utf-8 ​ 3,创建statement 执行sql 语句 1Statement stm =conn.createStatement(); stm.executeUpdata(sql) ​ 4,返回结果并处理 ​ 5.释放资源 (close) 防止SQL注入1234567891011sql=&quot;select *from user where username=? and password=?&quot;; // ?为占位符PreparedStatement ps=conn.prepareStatement(sql);ps.setObject(1,u.getname()); //设置 值ps.setObject(2,u.getpwd());Resultset rs=ps.executeQuery(); // 执行SQL语句 rs 为返回结果集if(rs.next())&#123; System.out.println(&quot;登录成功&quot;);&#125;else&#123; System.out.println(&quot;登录失败&quot;);&#125; 常见API详解1.DriverManager 类​ a.管理JDBC基础服务 ​ b.用于加载驱动和获取连接 2.Connection接口​ 代表数据库的连接,客户端和数据库交互时需要借助Connection完成 常见方法​ createStatement 创建向服务器发送 SQL 指令的Statement对象 ​ prepareStatement 创建向服务器发送预编译SQL 的preparedStatement对象 ​ setAutoCommit 设置事务是否自动提交 ​ commit() 提交事务 ​ rollback() 事务回滚 3.Statement 及其子接口​ 向数据库发送SQL指令 ​ executeQuery():用于发送查询的sql语句 ​ executeUpdate():用于发送增删改的sql语句 ​ execute():用于发送任意的sql语句 ​ addBatch():把多条sql语句添加到批处理命令中 ​ execteBatch():用于执行批处理命令 4.ResultSet 接口常见方法​ next():移动到下一行 ​ getString(int index):根据列位置获取指定类型数据 ​ getString(String ColName):根据列名称获取指定类型的数据 ​ getObject(int index):根据列位置获取任意类型的数据 ​ getObject(String ColName):根据列名称获取任意类型的数据 外置配置文件​ 1.创建jdbc.properties 1234driver&#x3D;com.mysql.jdbc.Driverurl&#x3D;jdbc:mysql:&#x2F;&#x2F;&#x2F;mydbuser&#x3D;rootpwd&#x3D;root ​ 2.读取配置文件 123456789101112131415161718static&#123; try &#123; //读取属性文件 Properties prop = new Properties(); InputStream is = BaseDao.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;); //流 prop.load(is); is.close(); //流对象关闭 //读到key-value driver = prop.getProperty(&quot;driver&quot;); url = prop.getProperty(&quot;url&quot;); username =prop.getProperty(&quot;username&quot;); password = prop.getProperty(&quot;password&quot;); //加载驱动 Class.forName(driver); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;","categories":[],"tags":[]}],"categories":[],"tags":[]}